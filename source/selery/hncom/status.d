/*
 * Copyright (c) 2017-2018 sel-project
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */
/**
 * Copyright: Copyright (c) 2017-2018 sel-project
 * License: MIT
 * Authors: Kripth
 * Source: $(HTTP github.com/sel-project/selery/source/selery/hncom/status.d, selery/hncom/status.d)
 */
module selery.hncom.status;

import std.typecons : Tuple;

import selery.hncom.about;
import selery.hncom.io;

/**
 * Used to calculate latency by both the hub and the node.
 * When this packet is received it should be immeditaly sent back to the sender
 * without any change.
 */
@clientbound @serverbound class Latency : HncomPacket {
	
	enum ubyte ID = 5;
	
	/**
	 * Id of the ping/pong. Should be unique for the session.
	 */
	uint id;
	
	mixin Make;
	
}

/**
 * Sends a logged message to the hub.
 */
@serverbound class Log : HncomPacket {
	
	enum ubyte ID = 6;
	
	struct Message { bool translation; string message; string[] params; }
	
	enum int NO_COMMAND = -1;
	
	enum int NO_WORLD = -1;
	
	/**
	 * Logged message or translation. It may contain Minecraft formatting codes.
	 */
	Message[] message;
	
	/**
	 * Unix time (in milliseconds) that indicates the exact creation time of the
	 * log (for ordering purposes).
	 */
	ulong timestamp;
	
	/**
	 * Identifier of the command that has generated the log or -1 if the
	 * log wasn't generated by a command.
	 */
	int commandId = NO_COMMAND;
	
	/**
	 * Id of the world that has generated the log, if the log comes from a world, -1 otherwise.
	 */
	int worldId = NO_WORLD;
	
	mixin Make;
	
}

/**
 * Executes a command on the node.
 */
@clientbound class RemoteCommand : HncomPacket {
	
	enum ubyte ID = 7;
	
	enum : ubyte {
		
		HUB = 0,
		WEB_ADMIN = 1,
		RCON = 2,
		
	}
	
	/**
	 * Origin of the command. It could be the hub itself or an external source.
	 */
	ubyte origin;
	
	/**
	 * Address of the sender if the command has been sent from an external source.
	 * It's `null` when the hub is the sender.
	 */
	HncomAddress sender;
	
	/**
	 * Commands and arguments that should be executed on the node.
	 * For example `say hello world` or `kill @a`.
	 */
	string command;
	
	/**
	 * Identifier of the command. It's sent back in Log's commandId field
	 * when the command generates output.
	 */
	uint commandId;
	
	mixin Make;
	
}

/**
 * Notifies the node that another node (that is not the receiver) has connected to the hub.
 */
@clientbound class AddNode : HncomPacket {
	
	enum ubyte ID = 8;
	
	/**
	 * Identifier given by the hub to uniquey identify the node.
	 */
	uint hubId;
	
	/**
	 * Node's name used for displaying and identification purposes.
	 */
	string name;
	
	/**
	 * Whether the node is a main node.
	 */
	bool main;
	
	/**
	 * Indicates the games and protocols accepted by the node.
	 */
	uint[][ubyte] acceptedGames;
	
	mixin Make;
	
}

/**
 * Notifies the node that another node, previously added with AddNode,
 * has disconnected from the hub.
 */
@clientbound class RemoveNode : HncomPacket {
	
	enum ubyte ID = 9;
	
	/**
	 * Node's id given by the hub.
	 */
	uint hubId;
	
	mixin Make;
	
}

/**
 * Receives a binary message sent by another node using SendMessage.
 */
@clientbound class ReceiveMessage : HncomPacket {
	
	enum ubyte ID = 10;
	
	/**
	 * Id of the node that has sent the message.
	 */
	uint sender;
	
	/**
	 * Indicates whether the message was broadcasted to every connected node.
	 */
	bool broadcasted;
	
	/**
	 * Bytes received. It could be serialised data or a plugin-defined packet.
	 */
	ubyte[] payload;
	
	mixin Make;
	
}

/**
 * Sends a binary message to some selected nodes or broadcast it.
 */
@serverbound class SendMessage : HncomPacket {
	
	enum ubyte ID = 11;
	
	/**
	 * Addressees of the message. If the array is empty the message is
	 * broadcasted to every connected node but the sender.
	 */
	uint[] addressees;
	
	/**
	 * Bytes to be sent/broadcasted. It may be serialised data or a plugin-defined packet.
	 */
	ubyte[] payload;
	
	mixin Make;
	
}

/**
 * Updates the server's display name.
 */
@clientbound class UpdateDisplayName : HncomPacket {
	
	enum ubyte ID = 12;
	
	string displayName;
	
	mixin Make;
	
}

/**
 * Updates the MOTD of one of the supported games.
 */
@clientbound class UpdateMOTD : HncomPacket {
	
	enum ubyte ID = 13;
	
	ubyte type;
	
	string motd;
	
	mixin Make;
	
}

/**
 * Updates the number of players on the server.
 */
@clientbound class UpdatePlayers : HncomPacket {
	
	enum ubyte ID = 14;
	
	enum int UNLIMITED = -1;
	
	/**
	 * Players currently online in the whole server (connected to a node).
	 */
	uint online;
	
	/**
	 * Maximum number of players that can connect to server, which is the sum of
	 * the max players of every connected node.
	 */
	int max;
	
	mixin Make;
	
}

/**
 * Updates the number of players that can be accepted by the node.
 * If the given number is smaller than the players currently connected
 * to the node no player should be kicked.
 */
@serverbound class UpdateMaxPlayers : HncomPacket {
	
	enum ubyte ID = 15;
	
	enum uint UNLIMITED = 0;
	
	/**
	 * Maximum number of players accepted by node.
	 */
	uint max;
	
	mixin Make;
	
}

/**
 * Updates the accepted protocols for one of the supported games.
 */
@clientbound class UpdateSupportedProtocols : HncomPacket {
	
	enum ubyte ID = 16;
	
	ubyte game;
	
	uint[] protocols;
	
	mixin Make;
	
}

/**
 * Updates the usage of the system's resources of the node.
 */
@serverbound class UpdateUsage : HncomPacket {
	
	enum ubyte ID = 17;
	
	/**
	 * Kibibytes of RAM used by the node.
	 */
	uint ram;
	
	/**
	 * Percentage of CPU used by the node. It may be higher than 100
	 * if the node has more than 1 CPU
	 */
	float cpu;
	
	mixin Make;
	
}

/**
 * Updates the language files. The content of this packet is usually
 * readed from plugins' language files.
 */
@serverbound class UpdateLanguageFiles : HncomPacket {
	
	enum ubyte ID = 18;
	
	string language;
	
	string[string] messages;
	
	mixin Make;
	
}

/**
 * Adds a plugin that has been loaded at runtime.
 */
@serverbound class AddPlugin : HncomPacket {
	
	enum ubyte ID = 19;
	
	/**
	 * Plugin's id given by the node. It must be unique.
	 */
	uint id;
	
	string name;
	
	string version_;
	
	mixin Make;
	
}

/**
 * Removes a plugin that has been unloaded at runtime.
 */
@serverbound class RemovePlugin : HncomPacket {
	
	enum ubyte ID = 20;
	
	/**
	 * Plugin's id given in the NodeInfo packet or in the AddPlugin packet.
	 */
	uint id;
	
	mixin Make;
	
}

/**
 * Notifies the hub that a new world has been created on the node.
 */
@serverbound class AddWorld : HncomPacket {
	
	enum ubyte ID = 21;
	
	/**
	 * Id of the world. Must be unique on the node.
	 */
	uint worldId;
	
	/**
	 * World's group id. Similar worlds can be grouped together
	 * and removed with the RemoveWorldGroup packet.
	 * If the world is independent and has no group the group id must be the same
	 * as the world id.
	 */
	uint groupId;
	
	/**
	 * Name of the world, it doesn't need to be unique.
	 */
	string name;
	
	/**
	 * World's dimension in the MCPE format (0: overworld, 1: nether, 2: end).
	 */
	ubyte dimension;
	
	/**
	 * Indicates whether the world is the node's default (the one where new players
	 * are spawned into if not handled by plugins).
	 * If the node does not support default worlds or it simply doesn't have one
	 * this field should be left to its default value (false).
	 * If the hub receives more than one default world it should consider the last
	 * received one as the default world.
	 */
	bool default_;
	
	mixin Make;
	
}

/**
 * Notifies the hub that a world has been removed from the node.
 */
@serverbound class RemoveWorld : HncomPacket {
	
	enum ubyte ID = 22;
	
	/**
	 * Id of the world that has been removed, previosly added using the
	 * AddWorld packet.
	 */
	uint worldId;
	
	mixin Make;
	
}

/**
 * Removes a group of worlds.
 */
@serverbound class RemoveWorldGroup : HncomPacket {
	
	enum ubyte ID = 23;
	
	uint groupId;
	
	mixin Make;
	
}
